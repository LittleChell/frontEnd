##	正则表达式

*	\r\n表示回车换行,\n表示换行，\r表示回车（但输出字符串时没有换行）

*	\d任意一个数字，0~9 中的任意一个；

*	\w任意一个字母或数字或下划线，也就是 A~Z,a~z,0~9,_ 中任意一个；

*	\s包括空格、制表符、换页符等空白字符的其中任意一个；

*	.小数点可以匹配除了换行符（/n）以外的任意一个字符；

*	\t代表制表符；

*	\b匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符，每个单词两边都算，只匹配但不替换，如字符aba fhaud faa在(/\b/g,"#")中为#aba# #fhaud# #faa#；

*	^与字符串开始的地方匹配，不匹配任何字符

*	$与字符串结束的地方匹配，不匹配任何字符

*	[ ]包含一系列字符，能够匹配其中任意一个字符,只能是一个。用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。

*	[ab5@]匹配 "a" 或 "b" 或 "5" 或 "@"；

*	[^abc]匹配 "a","b","c" 之外的任意一个字符，这里的^用在括号里；

*	[f-k]匹配 "f"~"k" 之间的任意一个字母

*	[^A-F0-3]匹配 "A"~"F","0"~"3" 之外的任意一个字符　　

*	{n}表达式重复n次，比如："/w{2}" 相当于 "/w/w"；"a{5}" 相当于 "aaaaa"

*	{m,n}表达式至少重复m次，最多重复n次，比如："ba{1,3}"可以匹配 "ba"或"baa"或"baaa"

*	{m,}表达式至少重复m次，比如："/w/d{2,}"可以匹配 "a12","_456","M12344"...

*	?匹配表达式0次或者1次，相当于 {0,1}，比如："a[cd]?"可以匹配 "a","ac","ad"

*	+表达式至少出现1次，相当于 {1,}，比如："a+b"可以匹配 "ab","aab","aaab"...

*	表达式不出现或出现任意次，相当于 {0,}，比如："/^*b"可以匹配 "b","^^^b"...

*	|左右两边表达式之间 "或" 关系，匹配左边或者右边

*	( ) 括号中的表达式可以单独匹配，适合表达式里面有像|这样的表达式

*	\a 表示重复的某个子项，比如：\1 匹配重复的第一个子项，如/(a)(b)(c)\1/-----匹配abca；\2 匹配重复的第二个子项，如/(a)(b)(c)\2/------匹配abcb

---

**正向前瞻（没有后瞻）:**

*	(?!)用法：X(?!Y)匹配X，仅当后面不紧跟着Y时，如果符合匹配，则只有X会被返回，Y不会被记返回。后面不再跟其它表达式。

*	(?=)用法：X(?=Y)：匹配X，仅当后面紧跟着Y时。如果符合匹配，则只有X会被返回，Y不会被返回。后面不再跟其它表达式。

*	(?:)用法：(X)(?:Y)(Z)匹配XYZ，但Y不会被捕获，$1 = X, $2 = Z，但是如果里面有括号会匹配里面的括号。这个方法主要方便不匹配子表达式。

*	占有优先量词X(?>Y)java中才有。

---

**replace()的用法：**<br>

replace(searchValue,replaceValue)；
searchValue是正则表达式，replaceValue可以是字符串。如果字符串中有几个特定字符的话，会被转换为特定字符串。

字符     替换文本
$&     与正则相匹配的字符串，可以对匹配的字符进行一些添加字符工作
$`     匹配字符串左边的字符，并把匹配的字符换成左边的字符
$'      匹配字符串右边的字符，并把匹配的字符换成右边的字符
$1,$2,$,3,…,$n 匹配结果中对应的分组匹配结果，使用的$n不够匹配项时，未出现的项会去掉。匹配的是括号里面项，以一组括号为单位，若有嵌套以左括号为准，如(a)(b)，$1为(a),$2为(b)；(a(b)),$1为(a(b)),$2为(b)

'1nimojs@126.com'.replace(/([a-z]+)(@)(.*)/,function($1,$2,$3,$4,$5,$6){
  return $1;//$2,$3,$4,$5,$6（开头的1不在匹配范围）
})中，依次返回$2,$3,$4,$5,$6，
第一个参数为匹配到的字符串，因此返回1nimojs@126.com；
第二个参数为第一个匹配项，因此返回1nimojs；
第三个参数为第二个匹配项，因此返回1@；
第四个参数为第三个匹配项，因此返回1126.com；
第五个参数为匹配到的索引位置，因此返回11；
第六个参数为整个字符串，因此返回11nimojs@126.com。
在函数中传入参数即是这样，如果传入参数不够，那么只从左边开始取到右边，未出现的参数项忽略
也可以使用arguments来传递参数，如arguments[0]代表第一个参数，arguments[1]代表第二个参数，以此类推。无论参数写成怎么样都按顺序来理解意思。

'1nimojs@126.com'.replace(/([a-z]+)(@)(.*)/,"$2$1")
这样有三个匹配项，只取前两项并换位置，输出1@nimojs；，这里$n是有大小顺序的


---

**贪婪与非贪婪：**

贪婪：从头开始匹配找到匹配项，继续往后找试图还能找到匹配项。

非贪婪：从头开始找到匹配项就不继续往下找了。

贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配；而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配。贪婪与非贪婪都是从头开始匹配到结尾。

匹配优先量词包括：“{m,n}”、“{m,}”、“?”、“*”和“+”。注：单个“?”是优先匹配。

忽略优先量词包括：“{m,n}?”、“{m,}?”、“??”、“*?”和“+?”。

对于简单的正则表达式，或是简单的源字符串，一般来说是非贪婪模式效率高些，而对于数量较大源字符串，或是复杂的正则表达式，一般来说是贪婪模式效率高些。

匹配相当于数组里面的指针往前移动。如果从目前点匹配到最后没找到匹配项，则初始指针往下调。

---

**regExp.exec(var)的用法:**<br>

返回的是匹配的项和子项（如果有的话），且只返回第一个匹配的，设置了全局g的话也是只返回第一个匹配的，不过会改变lastIndex，这样下次执行的时候会从lastIndex开始。
使用全局应该这样，可以改变lastIndex：
var a = "w1h2h3z4";
var x = /(h)(\d)+/g;
var b = x.exec(a);
var c = x.exec(a);
而不应该这样，改变不了lastIndex：
var a = "w1h2h3z4";
var x = /(h)(\d)+/g;
var b = /(h)(\d)+/g.exec(a);
var c = /(h)(\d)+/g.exec(a);