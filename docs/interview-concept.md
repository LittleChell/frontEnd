##	view * concept

*	清除缓存的机制

	1、meta方法：

		<META HTTP-EQUIV="pragma" CONTENT="no-cache"> 
		<META HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate"> 
		<META HTTP-EQUIV="expires" CONTENT="0">

	2、请求的url后面加上随机数或者时间戳

	3、文件末尾使用hash值

	4、服务器清理

	5、浏览器层面上勾选no-Cache，或者使用隐身模式。

*	cookie

	cookie有长度限制，有个数限制，可以通过每个cookie里面设置子cookie来增加cookie数量。

	cookie不能跨页面，有过期时间，没有设置过期时间的时候关闭浏览器即删除该cookie。

*	sessionStorage、localStorage和localStorage的区别
	
	sessionStorage和cookis类似，不过可以跨页面，适合小段数据存储，浏览器支持的话浏览器崩溃后重启依然可用。本地运行不可用。

	globalStorage（HTML5中被localStorage取代）用来跨会话存储，不过需要指定哪些域可以访问该数据，数据存储到通过JavaScript删除或者是用户清除浏览器缓存。

	localStorage，和globalStorage类似，不过规则更加严格，页面必须来自同一域名（子域名无效）、协议、端口（即不能跨域），数据存储到通过JavaScript删除或者是用户清除浏览器缓存。

*	GET和POST区别：

    GET方法：
	1. 使用GET方法时，查询字符串（键值对）被附加在URL地址后面一起发送到服务器：
    2.	GET请求能够被缓存
    3.	GET请求会保存在浏览器的浏览记录中
    4.	以GET请求的URL能够保存为浏览器书签
    5.	GET请求有长度限制
    6.	GET请求主要用以获取数据
    7.	安全性： 查询字符串会显示在地址栏的URL中，不安全，请不要使用GET请求提交敏感数据
    8.	数据类型限制： 只允许ASCII字符类型
 

    POST方法：
    1.	使用POST方法时，查询字符串在POST信息中单独存在，和HTTP请求一起发送到服务器：
    2.	POST请求不能被缓存下来
    3.	POST请求不会保存在浏览器浏览记录中
    4.	以POST请求的URL无法保存为浏览器书签
    5.	POST请求没有长度限制
    6.	POST请求主要用于传递数据
    7.	安全性：因为数据不会显示在地址栏中，也不会缓存下来或保存在浏览记录中，所以看POST求情比GET请求安全，但也不是最安全的方式。如需要传送敏感数据，请使用加密方式传输
    8.	数据类型限制：没有限制。允许二进制数据

*	三次握手

	第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

	第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

	第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

*	onload和Ready的区别

	onload必须等到页面内包括图片、链接等**所有元素加载完毕**后才能执行。通常需要操作到类似图片一类的元素才需要使用onload的方法。

	ready是jQuery的一个事件，在DOM结构已完全加载后执行，不必等到图片、链接等加载完毕，此时就可以安全地操作DOM元素了（是进行所有其它事件绑定及运行其它 jQuery 代码的最佳地方）。

*	script为什么放在尾部

	javascript会**阻塞**DOM的解析。

	当解析过程中遇到<script>标签的时候，先加载然后执行脚本（外链）或者先执行脚本（内联），再继续解析HTML文档。

	浏览器会在js执行后决定当前文档是否需要进行重新渲染或者重排。 
	js引擎线程和UI线程是互斥的， 所以js执行时会阻塞页面的渲染。

*	css为什么放在头部

	使得DOM可以一边解析一边渲染，减少白屏时间。

	放后面也可以渲染，但是白屏时间会增加。

*	css加载会造成阻塞吗？

	CSS是可以和其它资源并行下载的。

	外部样式会阻塞后续脚本**执行**（因为如果样式还没有加载和解析，脚本可能会得到错误的值），直到外部样式加载并解析完毕；不会阻塞后续外部脚本的**加载**。

	css加载不会阻塞DOM树的解析、
	css加载会阻塞DOM树的渲染、
	css加载会阻塞后面js语句的执行；

	当CSS后面跟着嵌入的JS的时候，该CSS就会出现阻塞后面资源下载的情况。而当把嵌入JS放到CSS前面，就不会出现阻塞的情况了。

	因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:
	
	使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)
	对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)
	合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)
	减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)

*	script脚本的阻塞

	新一代浏览器都支持并行下载JS，但是JS下载仍然会阻塞其它资源的下载（例如图片、css文件等）及渲染。

	开发者可以将脚本标识为defer，以使其不阻塞文档解析，并在文档解析结束后执行。Html5增加了标记脚本为异步的选项，以使脚本的解析执行使用另一个线程。


*	脏检查（angular.js）

	将原对象复制一份快照，在某个时间，比较现在对象与快照的值，如果不一样就表明发生了变化，这个策略要保留两份变量，而且要遍历对象，比较每个属性，这样会有一定的性能问题。

	angular.js中：
	1、	不会脏检查所有的对象。当对象被绑定到html中后，这个对象才会添加为检查对象（watcher）
	2、	不会脏检查所有的属性，同样当属性被绑定后，这个属性才会被列为检查的属性

*	!DOCTYPE的作用

	告诉浏览器document是使用哪个版本的html来编写的，目的是避免浏览器出现怪异渲染document的情况，以达到更好地兼容来渲染document的目的。
	它是一个声明，而不是html标签。

*	this的指向
	
	this最终都是指向最后一次调用的它的对象，对象中的function和function中的function不一样。

	1、	全局作用域下面的函数this指向window对象，因此直接调用该函数会导致里面的this指向的属性方法绑定到window上面；

	2、	**全局作用域**下面的匿名函数中this也是指向window对象；

	3、	对象中this指向调用该函数的对象；

	4、	构造函数中this指向构造的新对象；

	5、	通过call、apply可以改变this的指向；

	6、	function里面return function，里面的this指向当前function的作用域。

*	箭头函数this的修正

	对象中this修正了函数中this的指向，this指向箭头函数源头调用的对象。

*	使用new的过程发生了什么

	new 运算符创建一个自定义对象或具有构造函数的内置对象的实例。

	new Func()发生了如下的过程：

	1、	创建了新的对象，该对象继承自Func.prototype;

	2、	执行`Func`函数，this绑定到新的对象上。**new Func == new Func()**，在没有参数的情况下两者可以相互直接使用;

	3、	如果构造函数返回了一个“对象”，那么这个对象就会取代整个new 出来的结果。如果没有返回对象，那么new出来的结果就是步骤1中的对象。

*	从输入网址开始到页面渲染完成经历了怎么样的一个过程

	1、	输入网址，解析成IP地址；

	2、	浏览器给服务器发送http请求；

	3、	服务器接收到请求，处理后返回响应；

	4、	浏览器获得响应，得到html文档，开始构建dom树；

	5、	构建dom树的过程中，遇到其它资源就去请求加载其它资源，同时将css解析成树形数据结构；

	6、	构建render树、计算布局；

	7、	布局render树、绘制render树；

	8、	完成。

*	async和defer的区别

	两者都只能在有src的脚本中生效。

	async，表示后续文档的加载和渲染与js脚本的加载和执行是并行进行的，即异步执行。如果存在多个有async属性的脚本，它的加载和执行是紧紧挨着的，无论声明顺序如何，只要加载完成就立刻执行。
	用途：不依赖其它脚本的使用该属性。

	defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded事件触发执行之前。如果存在多个有defer属性的脚本，那么它们是按照加载顺序执行脚本的。
	用途：依赖其它脚本的使用defer。

	两者都可以通过改变脚本放置的位置来实现，defer往往比async晚执行。

*	typeof 与 instanceof的区别

	typeof用来判断变量的基本类型：undefined、object、number、string、function、boolean

	instanceof用来测试一个对象在其原型链中是否存在一个构造函数的 prototype属性。

*	什么是单页面应用，单页面应用的优缺点是什么？

	单页 Web 应用 (single-page application 简称为 SPA) 是一种特殊的 Web 应用。它将所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript 和 CSS。利用 JavaScript 动态的变换HTML的内（采用的是div切换显示和隐藏），从而实现UI与用户的交互，不会进行页面的重新加载或跳转。

	优点：更好的用户体验（页面速度与流畅方面）
	
	缺点：
		1.	不利于搜索引擎抓取，极差的SEO
		2.	首次加载数据大耗时长
		3.	独立模块编译的成本会越来越大
		4.	业务随着代码量增加而增加
	
*	单页不刷新路由跳转实现方式

	1、	hash
		路由里的 # 不叫锚点，称之为 hash
		监听哈希变化触发的事件 —— hashchange 事件
		改变url#后面的值不触发网页重载，但会记录到浏览器history中去。可以通过回退/前进按钮找回，或者history对象中的方法控制。

*	IE与其它浏览器的区别

	1.	盒子模型的差异

		IE8以下的盒子模型content属于border-box。

*	常见的HTTP状态码

	*	200 OK	服务器接收、理解、接受相应并返回所希望的响应头或数据体
	*	301 Moved Permanently	被请求的资源已被永久移动到新的位置
	*	302 Move temporarily	请求的资源临时从不同的URI响应请求
	*	304 Not Modified	文档内容没有发生改变，服务器应当返回这个状态码
	*	400 Bad Request		当前请求无法被服务器理解：语义有误或者请求的参数有误
	*	403 Forbidden	服务器已经理解请求但是拒绝执行
	*	404 Not Found	请求的资源未在服务器上面找到
	*	502 Bad Gateway	作为网关或者代理服务器尝试执行请求时，从上游服务器拿到了无效的响应。
	*	504 Gateway Timeout	作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器或者辅助服务器（例如DNS）收到响应。

	

	